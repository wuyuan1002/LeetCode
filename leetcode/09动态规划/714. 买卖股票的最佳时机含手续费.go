package main

// 714. 买卖股票的最佳时机含手续费

// 给定一个整数数组prices，其中第i个元素代表了第i天的股票价格 ；整数fee 代表了交易股票的手续费用。
//
// 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，
// 在卖出它之前你就不能再继续购买股票了。
// 返回获得利润的最大值。
//
// 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

// maxProfit714 .
// 同 leetcode 122 -- 只是本题在交易时（卖出股票时）需要扣除手续费，所以不能像122那样随意的交易
//
// 一天共有两种状态(状态j)：0持有股票、1未持有股票
// dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])
// 	 第i天为持有股票的状态时所持有的最大现金数量，可由两种情况得出：
// 	 1. 前一天就已经持有股票，保持现状 -- 即前一天手上的现金数量：dp[i - 1][0]
// 	 2. 当天买入股票 -- 即前一天不持有股票时手上的现金数量减去今天的股票价格： dp[i - 1][1] - prices[i]
// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee)
//   第i天为不持有股票的状态时所持有的最大现金数量，可由两种情况得出：
//   1. 前一天就不持有股票，保持现状 -- 即前一天手上的现金数量：dp[i - 1][1]
//   2. 当天卖出股票（卖出股票需要扣除手续费） -- 即按照当天价格卖掉手上持有的股票后得到的现金数量：dp[i - 1][0] + prices[i] - fee
func maxProfit714(prices []int, fee int) int {
	// 构造dp数组 -- dp[i][j]表示第i天状态j时所持有的最大现金数量(越大说明越有钱)
	dp := make([][2]int, len(prices))

	// 初始化dp数组 -- 初始化第一天的2种状态
	dp[0][0] = -prices[0] // 第1天持有股票时的现金数量 -- 钱都花了, 现在手上剩的钱的负的
	dp[0][1] = 0          // 第1天未持有股票 -- 手上没钱

	// 遍历每天的股票，计算每天持有股票和不持有股票所持有的最大现金数量
	for i := 1; i < len(prices); i++ {
		// 达到今天持有股票状态，有2种情况：
		// 1. 前一天已经持有股票
		// 2. 在今天买入股票
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])

		// 达到今天不持有股票状态，由2种情况：
		// 1.前一天就不持有股票
		// 2. 在当天卖出股票（扣除手续费）
		dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]-fee)
	}

	// 返回最后一天手上不持有股票时的现金数量
	return dp[len(prices)-1][1]
}
