package main

// 516. 最长回文子序列

// 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
// 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

// longestPalindromeSubseq .
// 同 leetcode 5、647 -- 回文子串需要连续，回文子序列不需要连续
//
// dp[i][j]表示字符串s在[i, j]范围内最长的回文子序列的长度
// dp[i][j] =
// 若 s[i] == s[j]，则 dp[i][j] = dp[i+1][j-1]+2 -- 相当于把s[i]和s[j]处两个字符加入到最长子序列中
// 若 s[i] != s[j]，则 dp[i][j] = max(dp[i+1][j], dp[i][j-1]) -- 两个字符不相等, 查看把两个分别加入能构成的最长长度
//
// 从递推公式：dp[i][j] = dp[i+1][j-1] + 2; 可以看出 递推公式是计算不到i和j相同时候的情况，
// 所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1
func longestPalindromeSubseq(s string) int {

	// 构造dp数组 -- dp[i][j]表示字符串s在[i, j]范围内最长的回文子序列的长度
	dp := make([][]int, len(s))
	for i := range dp {
		dp[i] = make([]int, len(s))
	}

	// 初始化dp数组 -- 也就是将dp[i][i]对角线上初始化为1
	// 从递推公式：s[i] == s[j]时，dp[i][j] = dp[i+1][j-1] + 2; 可以看出 递推公式是计算不到i和j相同时候的情况，
	// 所以需要初始化当i与j相同的情况，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1
	for i := 0; i < len(dp); i++ {
		dp[i][i] = 1
	}

	// 开始dp -- 因为dp[i][j]依赖于dp[i+1][j-1], 因此dp数组应该是从左下往右上遍历 -- 字符串i要倒着遍历
	for i := len(s) - 1; i >= 0; i-- {
		// j遍历区间 [i+1, len(s)) 的所有字符，不断计算[i, j]区间的最长回文子序列长度
		// 这里j从i+1开始而不是从i开始是因为i和j相同的情况已经在初始化dp数组时初始化过为1了，
		// 这里dp的时候不再考虑单独一个字符的情况了
		for j := i + 1; j < len(s); j++ {
			if s[i] == s[j] {
				dp[i][j] = dp[i+1][j-1] + 2
			} else {
				dp[i][j] = max(dp[i+1][j], dp[i][j-1])
			}
		}
	}

	// 返回s的[0, len(s)]范围内的最长回文子序列 -- 即整个字符串s的最长回文子序列长度
	return dp[0][len(s)-1]
}
