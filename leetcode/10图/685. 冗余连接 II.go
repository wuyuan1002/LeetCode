package main

// 685. 冗余连接 II

// 在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。
// 输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。
// 结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。
//
// 返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

// findRedundantDirectedConnection .
// 同 leetcode 684. 冗余连接 -- 684的边是无向的，而本题的边是有向的（edges[a, b]表示存在一条由a指向b的边，也就表示a是b的父节点，这条边的表示是由父节点指向子节点）
//
// leetcode 684 基于无向图，在无向图中判断是否有环，很容易想到可以使用 并查集
// leetcode 685 基于有向图，在有向图中判断是是否有环，需要使用拓扑排序（leetcode 207、leetcode 210，思想：贪心算法、BFS，概念：节点的度）
//
// 有向图表示的树，边的方向是由父节点指向子节点的，所以，在一颗合法的树中：
// 	1. 只有唯一的一个入度为0的节点，它是根节点
// 	2. 不是根节点的其它所有的节点入度为1，也就是除根节点外的所有节点只有一个父节点
// 	3. 不可能存在入度为2的节点
//
// 有n个节点，要有节点有两个入边或要要形成环的话，必须至少有n条边。同时题目说了只有一条多余的边，那么edges的大小必定是节点数量。
// 此题的关键点在于：寻找edges中导致有节点有多余入边的那条边或导致结果图产生环的那条边
//
// 因此，判断一个有向图表示的树是否合法，一定要满足两个条件：1. 没有入度大于1的节点、2. 边不存在环
// 所以首先统计所有节点入度是否有不满足规范的，若没有则将有向边当作无向边判断是否有环（leetcode 684 并查集）
//
// 为什么没有入度为2的节点，就可以将这里的有向边当作无向边看待呢？
// 正常情况下，有向边若要构成环，必须是 a->b,b->c,c->a 这种沿着边的方向可以构成的环，
// 而像 a->b,b->c,a->c 这种，虽然当作无向边的话构成了环，但是在有向边看来并没有构成环，
// 但是这种情况下a的入度为2了，会在第一步判断是否存在入度为2的时候就检查出来。而当有向图中没有入度为2的节点时，
// 此时若要构成环，有向图和无向图所需要满足的条件是一样的，即 a-b,b-c,a-c 分别存在边即可，而并不需要考虑边的方向了，因为已经没有入度为2的节点了
//
// 1. 如果存在入度为2的节点，最后要构成树，那么删除的边一定为该节点的某一条入边
// 2. 如果不存在入度为2的节点，那我们可以直接删除加入会构成环的边（同leetcode 684）
func findRedundantDirectedConnection(edges [][]int) []int {
	// 统计每一个节点的入度，定义一个数组用来记录每个节点的入度（即指向该节点的边的条数） -- 使用数组下标表示节点编号，因为没有0号节点所以数组长度为节点个数+1
	inDegree := make([]int, len(edges)+1)
	for i := range edges {
		inDegree[edges[i][1]]++
	}
	// 获取入度为2的节点的两条边，也就是同时指向同一个节点的两节点构成的边 -- 这里要倒序遍历，因为优先返回最后出现在二维数组中的答案
	invalidEdge := make([][]int, 0) // 因为入度为2说明这里要有的话一定是两条边，每条边连接的节点个数也是2，所以invalidEdge其实是一个 [2][2]int 的二维数组
	for i := len(edges) - 1; i >= 0; i-- {
		if inDegree[edges[i][1]] == 2 {
			invalidEdge = append(invalidEdge, edges[i])
		}
	}
	// 如果有入度为2的节点，那么一定是两条边里删一个，看删哪个可以构成树
	if len(invalidEdge) > 0 {
		// 判断删除当前边后能否构成合法的树，若能则返回当前边，否则说明应该删掉另一条边
		if isTreeAfterRemoveEdge(edges, invalidEdge[0]) {
			return invalidEdge[0]
		} else {
			return invalidEdge[1]
		}
	}

	// 若没有入度为2的节点，说明一定存在一条边使得构成环了，删掉加入会构成环的节点即可 -- 此处将整个图按照无向图判断是否有环（原因详见 line25）
	return findRedundantConnection(edges)
}

// isTreeAfterRemoveEdge .
// 使用并查集判断删掉某条边后是否能构成合法的树 -- 若能构成环则说明不是合法的树
//
// 此处可以将有向图当作无向图，判断各个边能否构成环，因为这里是要删除一个入度为2的节点的边的，
// 此时整个图中就不存在入度为2的节点了，可以将整个图按照无向图判断（原因详见 line25）
func isTreeAfterRemoveEdge(edges [][]int, removeEdge []int) bool {
	// 初始化并查集 -- 使用数组下标表示节点编号，因为没有0号节点所以数组长度为节点个数+1
	parent := make([]int, len(edges)+1)
	for i := range parent {
		parent[i] = i
	}

	// 不断遍历每条边，将其进行连接，若连接出现环则返回导致出现环的两节点
	for i := range edges {
		// 获取当前边的两个节点 -- 两节点间存在一条无向边
		node1, node2 := edges[i][0], edges[i][1]

		// 去除被删掉的边
		if node1 == removeEdge[0] && node2 == removeEdge[1] {
			continue
		}

		// 尝试将当前两节点连接（即连接两节点的父节点，合并两节点所在的连通分量），若不能连接则说明连接当前两节点导致出现了环，为附加的边，返回该条边
		if !connect(parent, node1, node2) {
			return false
		}
	}
	return true
}
