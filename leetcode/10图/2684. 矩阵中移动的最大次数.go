package main

// 2684. 矩阵中移动的最大次数

// 给你一个下标从 0 开始、大小为 m x n 的矩阵 grid ，矩阵由若干 正 整数组成。
//
// 你可以从矩阵第一列中的 任一 单元格出发，按以下方式遍历 grid ：
//
// 从单元格 (row, col) 可以移动到 (row - 1, col + 1)、(row, col + 1) 和 (row + 1, col + 1) 三个单元格中任一满足值 严格 大于当前单元格的单元格。
// 返回你在矩阵中能够 移动 的 最大 次数。

// maxMoves .
// 从第一列的任一单元格出发向右移动，移动的最大次数就是地图总共有多少列，
// 但是每一个单元格向右移动，只能移动到比自己大的下一列相邻单元格，因此最多能向右移动几列就是最终的结果
//
// 首先将第一列所有行的坐标加入到集合表示该点能够到达，然后遍历集合，将能到达的下一列坐标加入到集合，
// 接着继续遍历集合继续将能够到达的下一列坐标加入到集合，每到达下一列将移动的次数加1，
// 不断遍历下一列能够到达的坐标，直到遍历到最后一列或集合中没有元素，返回移动的次数
func maxMoves(grid [][]int) int {

	// 能够到达当前列的哪些横坐标
	canMoveOn := make(map[int]bool)

	// 第一列都可以到达，默认加入到集合中 -- 从第一列开始向后移动
	for i := 0; i < len(grid); i++ {
		canMoveOn[i] = true
	}

	// 从第二列开始遍历，查找前一列能够到达当前列的哪些横坐标
	for j := 1; j < len(grid[0]); j++ {
		// 前一列可以移动到当前列的哪些横坐标
		next := make(map[int]bool)

		// 遍历能够到达前一列的所有横坐标，查看这些坐标中能够到达当前列的哪些横坐标
		for i := range canMoveOn {
			if i > 0 && grid[i-1][j] > grid[i][j-1] {
				next[i-1] = true
			}
			if grid[i][j] > grid[i][j-1] {
				next[i] = true
			}
			if i < len(grid)-1 && grid[i+1][j] > grid[i][j-1] {
				next[i+1] = true
			}
		}

		// 若前一列没有坐标能够到达当前列，那么当前列是不可达的，所以前一列是第几列那么最大移动次数就是几
		if len(next) == 0 {
			return j - 1
		}

		// next保存了前一列能够到达当前列的所有横坐标，开始遍历求当前列能够到达下一列的哪些横坐标，
		// 赋值给canMoveOn开始遍历当前列能够到达下一列的哪些横坐标
		canMoveOn = next
	}

	// 遍历到最后一列，说明可以从第一列移动到最后一列，那么总列数减一就是最多能移动了几次
	return len(grid[0]) - 1
}
