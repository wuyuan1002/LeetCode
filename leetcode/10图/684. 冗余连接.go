package main

// 684. 冗余连接

// 树可以看成是一个连通且 无环 的 无向 图。
//
// 给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。
// 图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。
//
// 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的那个。

// findRedundantConnection .
// 同 leetcode 685. 冗余连接 II -- 本题的边是无向的，edges[a, b]表示在a与b之间存在一条无向边
//
// 并查集：
// 用于解决一些元素分组的问题，用来管理一系列不相交的集合，即图中互相没有边连接的孤立节点区域，也就是图中互相没有被连通的节点区域（即连通分量）
// 每个集合中的代表（该连通分量的代表（根节点））即该连通分量中那个父节点为自己的节点
// 如果要连通两个点，那么则让其中的（任意）一个节点的根节点接到另一个节点的根节点上（也就是将两个集合合并，合并代表元素）
//
// 树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边
//
// 初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个节点是否属于相同的连通分量
// 如果两个节点属于不同的连通分量，则说明在遍历到当前的边之前，这两个节点之间不连通，因此当前的边不会导致环出现，合并这两个节点的连通分量
// 如果两个节点属于相同的连通分量，则说明在遍历到当前的边之前，这两个节点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回
func findRedundantConnection(edges [][]int) []int {
	// 定义一个数组表示并查集，用来存储每个节点的父节点是哪个 -- parent[a]=b 节点a与节点b直接存在一条边，但是这条边是无向的
	// 初始时将每个节点的父节点指向为自己，每个节点都是单独的连通分量
	// 使用数组下标表示节点编号，因为没有0号节点所以并查集的数组长度为节点个数+1
	parent := make([]int, len(edges)+1)
	for i := range parent {
		parent[i] = i
	}

	// 不断遍历每条边，将其进行连接，若连接出现环则返回导致出现环的两节点
	for i := range edges {
		// 获取当前边的两个节点 -- 两节点间存在一条无向边
		node1, node2 := edges[i][0], edges[i][1]

		// 尝试将当前两节点连接（即连接两节点的父节点，合并两节点所在的连通分量），若不能连接则说明连接当前两节点导致出现了环，为附加的边，返回该条边
		if !connect(parent, node1, node2) {
			return edges[i]
		}
	}

	return []int{}
}

// connect 给定两个节点尝试将其进行连接（合并两个连通分量），若两节点已处于同一个连通分量中则说明连接这两节点会出现环，返回false，若两节点分别在不同的连通分量中，则将两节点进行相连，返回true
func connect(parent []int, node1, node2 int) bool {
	// 分别获取两节点所在连通分量的跟节点
	root1, root2 := getRoot(parent, node1), getRoot(parent, node2)
	// 若跟节点相同说明两节点已经处于同一个连通分量重，再将这两节点连接会出现环，返回false
	if root1 == root2 {
		return false
	}
	// 连接两节点 -- 将任意一个节点的跟节点连接到另一个节点的跟节点上，将两个连通分量合并成了一个
	parent[root1] = root2
	return true
}

// getRoot 给定一个节点，获取该节点所在该连通分量的根节点
func getRoot(parent []int, node int) int {
	if parent[node] != node {
		// 若当前节点的父节点不是当前节点的话，说明当前节点不是当前连通分量的跟节点
		// 不断将当前节点的父节点设置为当前节点父节点的父节点，直到找到整个连通分量的跟节点后返回
		//
		// 也就是对节点node进行查找后，parent[node]存的其实是其所在连通分量的跟节点了，而不是其直接相连的父节点，
		// 这样做是方便后续再对node进行查找时方便直接获取其跟节点是谁，而不是再次一层一层父节点向上查找
		parent[node] = getRoot(parent, parent[node])
	}
	return parent[node]
}
