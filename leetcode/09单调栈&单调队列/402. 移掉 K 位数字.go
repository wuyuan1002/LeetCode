package main

import "strings"

// 402. 移掉 K 位数字

// 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。
// 请你以字符串形式返回这个最小的数字。

// removeKdigits .
// 保证靠前的数字尽可能小才可以保证最终的得数最小，也就是从高位开始优先将每个数字前面比其大的数字删掉
//
// 使用单调递增栈，栈顶元素为栈内最大值，当新入栈的元素大于栈顶元素时，说明栈内高位的数字比其右侧数字大了，
// 此时不断从栈顶开始将大于当前元素的高位数字出栈，这些数字就是要被删掉的数字，直到新的栈顶元素不大于当前数字或栈为空或已经删除够k个数字
func removeKdigits(num string, k int) string {
	// 单调递增栈 -- 从栈底到栈顶单调递增，栈内为当前高位数字能构成的最小值
	stack := make([]byte, 0)

	for i := 0; i < len(num); i++ {
		// 若当前元素比栈顶元素小时，不断将栈内比当前元素大的元素出栈表示将其删除
		for len(stack) > 0 && num[i] < stack[len(stack)-1] && k > 0 {
			stack = stack[:len(stack)-1]
			k--
		}

		// 将当前元素入栈 -- 若k>0时新入栈的元素一定是栈内最大值，当k<=0时说明已经不需要继续删除元素了，此时相当于将字符串剩余字符按照顺序全部入栈
		stack = append(stack, num[i])
	}

	// 当比起左侧数字小的数字个数小于k时会导致实际删除的数字个数不满k个（如"12345"，不存在比其左侧小的数字，其本身构成了最小值），
	// 此时需要从栈顶删除额外的数字使得总共删除的数字个数为k -- 如k==2时， "12345" -> "123"，
	// 为什么是从栈顶删呢？因为栈顶到栈底是单调递增的，越靠近栈顶的元素越大，所以需要将大的数字删掉"12345" -> "123"，而不是"12345" -> "345"
	stack = stack[:len(stack)-k]

	// 清理掉总结果左侧的0 -- 如 "000137" -> "137"
	result := strings.TrimLeft(string(stack), "0")
	if result == "" {
		return "0"
	}

	return result
}
