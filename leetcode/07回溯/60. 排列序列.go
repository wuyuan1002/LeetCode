package main

// 60. 排列序列

// 给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。
//
// 按大小顺序列出所有排列情况，并一一标记，
// 给定 n 和 k，返回第 k 个排列。
//
// 提示：
// 1 <= n <= 9
// 1 <= k <= n!

// getPermutation .
// leetcode 46. 全排列
// leetcode 47. 全排列 II
//
//  1. 回溯法在求全排列的过程中将k传入，找到一个排列就将k递减，直到找到第k个排列数后返回（此方法需要循环k次进行寻找）
//     题目限制的是1 <= n <= 9，不过假设当 n >= 10 后，回溯法将不能用于解此题，
//     因为先排1开头的、再排2开头的... 这个思路是错的。因为当k大于10以后，
//     应该先排10开头的、再排1开头的、再排11开头的、再排12开头的... 19排完了才排2开头的
//
//  2. 使用数学规律除法定位计算第k个排列数字的前n位应该是什么，而不是挨个循环查找
//     对于 n 个不同的元素（例如数 1,2,...,n），它们可以组成的排列总数目为 n!
//
//     如给定 n = 6、k = 373，则数组为 nums = [1,2,3,4,5,6]，
//     其中，以 1 开头的全排列有 5! 个，以 2 开头的全排列有 5! 个 ...，一共 6 * 5! = 6! 个排列
//     a. 故当 k = 373 时，全排列的第一个数字应该是 nums[k / 5!] = 4
//     b. 数组删除 4, 此时 nums = [1,2,3,5,6]; k = k % 5! = 12
//     c. 接下来就是在 nums 中找第 12 个全排列数字，重复 a、b 即可
func getPermutation(n int, k int) string {
	// 总结果
	result := make([]byte, n)

	// 构造一个长度为n的数组 -- [1,2,3,...,n]
	nums := make([]int, n)
	for i := range nums {
		nums[i] = i + 1
	}

	// 先将k减1，因为数组下标从0开始，相当于在n个数字的全排列中找到下标为 k-1 的那个数，因此k先减1
	k--

	// 分别定位结果的前第i位是哪个数字
	for i := 0; i < n; i++ {
		// 计算 当前剩余数字总个数-1 的阶乘数 -- 如剩余5个数字，则求4的阶乘
		factor := factorial(n - i - 1)
		// 定位总结果的前第i个数字并加入到总结果
		idx := k / factor
		result[i] = byte(nums[idx] + '0')
		// 将已使用归位的前第i个数字从数组中移除
		nums = append(nums[:idx], nums[idx+1:]...)

		// 计算在剩余数组数字中找前k个排列
		k = k % factor
	}

	return string(result)
}

// factorial 求n的阶乘
func factorial(n int) int {
	num := 1
	for ; n > 0; n-- {
		num *= n
	}
	return num
}
