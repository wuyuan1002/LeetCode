package main

import "math"

// 132. 分割回文串 II

// 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串
//
// 返回符合要求的 最少分割次数 。

// minCut .
// 同 leetcode 131. 分割回文串
// 预处理字符串，先使用二维数组先记录下字符串每个范围是否为回文串，然后进行动态规划计算最小的分割次数
//
// g[l][r]表示s[l,r]这一段是否为回文串
//
// dp[i]表示将字符串的前缀s[0, i]部分分割为回文串的最少分割次数
// dp[i] = min(dp[i], dp[l]+1)
func minCut(s string) int {

	// 预处理字符串，记录每个子串是否为回文串
	g := make([][]bool, len(s))
	for i := range g {
		g[i] = make([]bool, len(s))
	}

	// 遍历左右指针，计算每个子串s[l,r]是否为回文串
	for r := 0; r < len(s); r++ {
		for l := 0; l <= r; l++ {
			if s[l] == s[r] && (r-l <= 2 || g[l+1][r-1]) {
				g[l][r] = true
			}
		}
	}

	// -------

	// 创建dp数组 -- dp[i]表示将字符串的前缀s[0, i]部分分割为回文串的最少分割次数
	dp := make([]int, len(s))

	// dp数组初始化 -- 第一个字符本身就是回文串，因此不需要分割
	dp[0] = 0

	// 从第2个字符开始计算前缀s[0, i]部分分割为回文串的最少分割次数
	for i := 1; i < len(s); i++ {
		if g[0][i] {
			// 如果前缀s[0, i]本身是一个大的回文串，则不需要分割即可
			dp[i] = 0
		} else {
			// 如果前缀s[0, i]本身不是一个大的回文串，那么计算将s[0, i]拆分成回文串需要的最小分割次数

			// 先将分割次数置为一个最大值
			dp[i] = math.MaxInt32

			// 求将子串s[0, i]拆为回文串的最小分割次数
			for l := 0; l < i; l++ {
				if g[l+1][i] {
					// 子串s[0, i]可以拆为 s[0, l] + s[l+1, i]
					// dp[l]表示将子串s[0, l]拆为回文串的最小分割次数
					//
					// 又因为子串s[l+1, i]是回文串，只需要增加一次拆分操作即可
					// 因此将子串 s[0, l] + s[l+1, i] 拆分为回文串的最小操作次数为 dp[l] + 1
					dp[i] = min(dp[i], dp[l]+1)
				}
			}
		}
	}

	return dp[len(s)-1]
}
