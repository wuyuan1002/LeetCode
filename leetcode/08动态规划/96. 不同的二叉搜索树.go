package main

// 96. 不同的二叉搜索树

// 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树有多少种？
// 返回满足题意的二叉搜索树的种数。

// numTrees .
// 同 leetcode 70. 爬楼梯、95. 不同的二叉搜索树 II
// dp[i]表示总数为i个节点时所能的不同二叉排序树的总数
// dp[i] = dp[i] + dp[j - 1] * dp[i - j]
func numTrees(n int) int {
	// 构造dp数组 -- dp[i]表示总数为i个节点时所能的不同二叉排序树的总数
	dp := make([]int, n+1)
	// 初始化dp数组 -- dp[0]表示为只有0个节点的空树，空树也是一颗树，只有一种排列方式
	dp[0] = 1

	// 遍历求当总节点个数为 1～n 的不同二叉排序树的总数
	for i := 1; i <= n; i++ {
		// 当总节点个数为i时，选择第j个节点作为根结点时的不同二叉排序树的数量 -- 左子树的排列个数 * 右子树的排列个数
		for j := 1; j <= i; j++ {
			dp[i] += dp[j-1] * dp[i-j]
		}
	}

	// 返回总节点个数为n的数量
	return dp[n]
}
