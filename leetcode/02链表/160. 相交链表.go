package main

// 160. 相交链表

// 给你两个单链表的头节点headA 和 headB ，
// 请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
//
// 题目数据 保证 整个链式结构中不存在环。
// 注意，函数返回结果后，链表必须 保持其原始结构 。

// getIntersectionNode .
// Offer 52
//
// 1.把两个链表分别入栈，然后同时弹出元素，直到第一个不相等的元素
// 2.将第一个链表全部入map，之后从头到尾遍历第二个链表，判断map中是否存在节点
// 3.双指针
// 	如果两个链表相交，那么相交点之后的长度是相同的，让两个链表从距离末尾同等距离的最远位置开始遍历（即一个指针从短链表的头节点开始遍历），第一个相同的节点就是相交节点
// 	为此，我们必须消除两个链表的长度差，使得其中一个指针指向短链表的头节点，一个指针指向长链表中剩余长度正好等于短链表长度的节点
//
// 	指针 p 指向 A 链表，指针 q 指向 B 链表，依次往后遍历
// 	如果 p 到了末尾，则 p = headB 继续遍历
// 	如果 q 到了末尾，则 q = headA 继续遍历
// 	比较长的链表指针指向较短链表head时，长度差就消除了
//
//  继续同时向后移动两指针，直到两指针相同说明指向了相同元素或同时到达末尾
// 	因此，只需要将最短链表遍历两次即可找到位置
// 	遍历结束时，若有交点，则两指针同时指向交点，若没有交点，则两指针分别同时指向两链表末尾nil
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}

	p, q := headA, headB
	for p != q {
		if p != nil {
			p = p.Next
		} else {
			p = headB
		}

		if q != nil {
			q = q.Next
		} else {
			q = headA
		}
	}

	return p
}
