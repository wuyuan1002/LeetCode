package main

// 89. 格雷编码

// n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：
// 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
// 第一个整数是 0
// 一个整数在序列中出现 不超过一次
// 每对 相邻 整数的二进制表示 恰好一位不同 ，且
// 第一个 和 最后一个 整数的二进制表示 恰好一位不同
// 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

// grayCode .
// n阶格雷码是指二进制位有n位的满足格雷码规则的数 -- 如101为3阶，1101为4阶
// 求n阶格雷码序列也就是求所有数都满足格雷码规则且所有数的二进制位都为n位的数的集合
// 因此n阶格雷码的个数为2的n次方个
//
// 简述格雷码的规则：任意相邻的数的二进制位只有1位不同，且第一个数字和最后一个数字的二进制位也只有1位不同
//
// 对与n阶格雷码可以由其前一阶n-1阶格雷码推到得出，设 n 阶格雷码集合为 G(n)，则 G(n+1) 阶格雷码可以通过以下三步得到：
// 1. 对G(n)的每个数的二进制位前面添加0得到R(n)
// 2. 将G(n)的每个数首位调换位置后在每个数的二进制位前面添加1得到另一个序列P(n)
// 3. 此时R(n)和P(n)分别为新阶格雷码的一般，将其进行拼接即得到 G(n+1) = R(n) + P(n)
func grayCode(n int) []int {
	result := make([]int, 0, 1<<n) // 2的n次方个，第一位为0表示0阶格雷码为0（result[0]=0）
	for i := 1; i <= n; i++ {
		for j := len(result) - 1; j >= 0; j-- {
			result = append(result, result[j]|1<<(i-1))
		}
	}
	return result
}
