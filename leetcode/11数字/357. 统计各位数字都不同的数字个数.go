package main

// 357. 统计各位数字都不同的数字个数

// 给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 <= x < 10n 。

// countNumbersWithUniqueDigits .
// n=0时，只有一种选择，直接返回1
// n=1时，只有一位数字，范围[0, 9]，返回10
// n>1时，最终的数字一共为n位，从高位到低位进行计算：
//    第1位（最高位）的选择为[1, 9] -- 共9种，
//    第2位的选择为[0, 9]再减去第1位选择的数字 -- 共10-1=9种，
//    第3位的选择为[0, 9]再减去前两位选择的数字 -- 共10-2=8种，
//    第4位的选择为[0, 9]再减去前三位选择的数字 -- 共10-3=7种，
//    ...
//    第n-1位的选择为[0, 9]再减去前n-2位选择的数字 -- 共10-n-2种，
//    第n位的选择为[0, 9]再减去前n-1位选择的数字 -- 共10-n-1种
//
//    所以数字总位数为n的各位数字各不相同的种类为上面各种情况相乘的得数，即 res = 9*9*8*7*...*(10-n-2)*(10-n-1)
//
// 而题目要求是数字位数最多为n而不是要求只求位数为n的结果，所以总结果为 n in [1, n] 的所有情况的和 -- 即 n=1 + n=2 + ... + n=n-1, n=n 所有位数的各位数字各不相同的结果的和
func countNumbersWithUniqueDigits(n int) int {
	if n == 0 {
		return 1
	}
	if n == 1 {
		return 10
	}

	// 总结果（默认为10表示将n=1的个数加到总结果）、数字总位数为i+2时的结果个数（默认为9表示最高位的选择个数为9）
	// 这里currentRes不断相乘，原因是假设当前n=3，currentRes表示n=3的总个数，而当n=4时，只需将 n=3时的总个数currentRes * (9-前3位不能选的数字个数) 即可，也就是n=4的结果可以直接由n=3的结果进行一次运算得到
	result, currentRes := 10, 9
	for i := 0; i < n-1; i++ {
		// 求出n=i+2的结果个数
		currentRes *= 9 - i
		// 将n=i+2的结果个数加到总结果
		result += currentRes
	}

	return result
}
