package main

// 2401. 最长优雅子数组

// 给你一个由 正 整数组成的数组 nums 。
//
// 如果 nums 的子数组中位于 不同 位置的每对元素按位 与（AND）运算的结果等于 0 ，
// 则称该子数组为 优雅 子数组。 返回 最长 的优雅子数组的长度。
//
// 子数组 是数组中的一个 连续 部分。
// 注意：长度为 1 的子数组始终视作优雅子数组。

// longestNiceSubarray .
// 滑动窗口
// 两个不同的数相与结果为0，那么这两个数一定没有一个同一位置的1
//
// 维护一个变量mask为当前所有数的或的结果用来保存当前窗口中所有数字的二进制位上的1（mask中某一个二进制1一定是由某一个数字带来的，不会出现在同一位置有多个数字的二进制位为1，因为窗口中的数字一定都是满足条件的数字，也就是窗口中的数字做与运算一定为0）
// 右指针向前移动加入一个新的数字时，
// 若该数字与mask相与为0，那么将mask或运算上这个数（也就是将这个数字新带进来的二进制1保存下来）
// 若该数字与mask相与不为0，说明该数字存在二进制位1在mask中已经存在了，不断向前移动左指针将左指针指向的数字的二进制1从mask中去除，直到新加入的数字与mask与运算为0
func longestNiceSubarray(nums []int) int {
	result := 1     // 总结果 -- 长度为1的子数组也是优雅子数组，所以至少是一个数字作为优雅子数组
	mask := nums[0] // 维护一个变量mask为当前所有数的或的结果用来保存当前窗口中所有数字的二进制位上的1

	// 不断向后移动右指针将新数字加入到窗口中
	for l, r := 0, 1; r < len(nums); r++ {
		// 若当前新加入数字与当前窗口中的1有冲突，则不断向前移动左指针，将左指针指向数字提供的1从窗口中去除
		for l < r && nums[r]&mask != 0 {
			mask ^= nums[l]
			l++
		}

		// 将当前右指针指向的数字加入到窗口中
		mask |= nums[r]

		// 统计最大窗口长度
		result = max(result, r-l+1)
	}

	return result
}
