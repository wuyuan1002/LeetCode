package main

// 2401. 最长优雅子数组

// 给你一个由 正 整数组成的数组 nums 。
//
// 如果 nums 的子数组中位于 不同 位置的每对元素按位 与（AND）运算的结果等于 0 ，
// 则称该子数组为 优雅 子数组。 返回 最长 的优雅子数组的长度。
//
// 子数组 是数组中的一个 连续 部分。
// 注意：长度为 1 的子数组始终视作优雅子数组。

// longestNiceSubarray .
// 滑动窗口
//
// 两个不同的数相与结果为0，那么这两个数一定没有一个同一位置的1
//
// 维护一个变量mask为当前窗口中的所有数或运算的结果用来保存当前窗口中所有数字的二进制位上的1（mask中某一个二进制1一定是由某一个数字带来的，
// 不会出现mask的同一位置的1由多个数字带来的情况，因为窗口中的数字互相做与运算一定为0，即窗口中的所有数字不可能在同一个二进制位上同时为1）
//
// 向右移动右指针加入一个新的数字时：
// 若该数字与mask相与为0，那么将mask或运算上这个数（也就是将这个数字新带进来的二进制1保存下来）-- 当前数字与窗口中的所有数字相与为0
// 若该数字与mask相与不为0，说明该数字存在二进制位1在mask中已经存在了，不断向右移动左指针将左指针指向的数字的二进制1从mask中去除，直到新加入的数字与mask与运算为0
func longestNiceSubarray(nums []int) int {
	result := 1     // 总结果 -- 长度为1的子数组也是优雅子数组，所以至少是一个数字作为优雅子数组
	mask := nums[0] // 维护一个变量mask为当前窗口中所有数或运算的结果用来保存当前窗口中所有数字的二进制位上的1

	// 不断向右移动右指针将新数字加入到窗口中
	for l, r := 0, 1; r < len(nums); r++ {
		// 若当前新加入数字与当前窗口中的1有冲突，说明新加入的数字不能保持当前窗口为优雅子数组了 -- 不断向右移动左指针，将左指针指向数字提供的1从mask中去除
		for l < r && nums[r]&mask != 0 {
			mask ^= nums[l]
			l++
		}

		// 将当前右指针指向的数字提供的1加入到mask中
		mask |= nums[r]

		// 统计最大窗口长度
		result = max(result, r-l+1)
	}

	return result
}
