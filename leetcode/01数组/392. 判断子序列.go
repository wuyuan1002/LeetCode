package main

// 392. 判断子序列

// 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
//
// 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。
// （例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
//
// 进阶：
//
// 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，
// 你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

// isSubsequence1 .
// 1. 双指针
// 使用两个指针i和j分别指向s和t的头部，不断遍历i和j，判断两个字符是否相等，最终若在t中找到了s中的所有字符，说明s是t的子序列
func isSubsequence1(s string, t string) bool {
	i, j := 0, 0
	// 不断循环遍历i和j指向的字符是否相等 -- 在t中不断寻找s中的所有字符
	for i < len(s) && j < len(t) {
		if s[i] == t[j] {
			// 若当前i指向的s中的字符在t中找到了，向前移动i指向下一个字符，继续在t中寻找s[i]
			i++
		}
		// 不断遍历t中的下一个字符
		j++
	}

	// 最终i或j到达了字符串末尾
	// 若最终i到达了s的末尾，则说明s中的所有字符在t中都找到了 -- s是t的子序列
	// 若最终i没有到达s的末尾，说明遍历完整个t，都没有找完s中的所有字符 -- s不是t的子序列
	return i == len(s)
}

// isSubsequence2 .
// 2. 动态规划 -- leetcode 1143. 最长公共子序列
// 求出s和t的最长公共子序列, 然后判断最长公共子序列长度是否等于s的长度
func isSubsequence2(s string, t string) bool {

	// 构造dp数组 -- dp[i][j]表示以下标i-1结尾的s和下标j-1结尾的t的子串的最长公共子序列长度
	dp := make([][]int, len(s)+1)
	for i := range dp {
		dp[i] = make([]int, len(t)+1)
	}

	// 初始化dp数组 -- dp[0][0]、dp[i][0]、dp[0][j]其实都是没有意义的，只是为了dp结果正确
	// dp[0][0]、dp[i][0]、dp[0][j]的默认值应该为0，这些位置在构造dp数组的时候默认就是0，因此不需要单独初始化赋值为0

	// 开始dp -- 计算以每个下标结束的两个子串的公共子序列长度
	for i := 1; i <= len(s); i++ {
		for j := 1; j <= len(t); j++ {
			if s[i-1] == t[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i][j-1])
			}
		}
	}

	// 返回最终两个完整字符串的公共子序列长度是否等于s的长度
	return dp[len(s)][len(t)] == len(s)
}
