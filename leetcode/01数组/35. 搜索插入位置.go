package main

// 35. 搜索插入位置

// 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
// 如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
//
// 请必须使用时间复杂度为 O(log n) 的算法。

// searchInsert .
// leetcode 704、33、35、153、offer 11
//
// 二分查找 -- 若找到目标值则直接返回，若没找到则左指针的位置就是它的插入位置（因为返回时左指针已经向右移动过一位了，此位置就是插入位置）
//
// 一共有以下4种可能：
// 1. 目标值存在于数组中 -- 找到后直接返回下标
// 2. 目标值小于数组中的所有元素 -- 整个二分过程中左指针始终不动，右指针不断向左移动直至移动到左指针位置，最终返回左指针位置 -- 插入位置就是也就是下标为0的位置
// 3. 目标值大于数组中的所有元素 -- 整个二分过程中右指针始终不动，左指针不断向右移动直至移动到右指针位置，此时会再次进入循环发现仍然比目标值小，再将左指针向右移动一位来到了右指针右侧，最终返回左指针位置 -- 插入位置也就是下标为len(nums)的位置
// 4. 目标值在数组中数字的某个区间内但不等于数组中任何数字 -- 二分的倒数第二次循环，左指针与右指针一定是相邻的，此时mid由于除法向下兼容也会指向左指针位置，发现mid指向数字比目标值小，将左指针向右移动一位与右指针位置重合，数组中此位置的数字比目标值大（最终的插入位置），然后再经过最后一次循环将右指针向左移动一位后最终返回左指针位置 -- 插入位置也就是左指针指向的位置
func searchInsert(nums []int, target int) int {
	if nums == nil || len(nums) == 0 {
		return -1
	}
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + (r-l)/2
		if nums[mid] > target {
			r = mid - 1
		} else if nums[mid] < target {
			l = mid + 1
		} else {
			return mid
		}
	}
	return l
}
