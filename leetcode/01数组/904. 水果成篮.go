package main

// 904. 水果成篮

// 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。
//
// 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：
//
// 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
// 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
// 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
// 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。

// totalFruit .
// 双指针，使用一个map记录当前水果的类型及其个数
// 当窗口中出现的水果类型数量大于果篮数量时，则向前移动左指针将蓝中水果进行删除，直到水果种类为果篮个数
// 因为一棵树只能采摘一个水果，所以最终收集的水果数量其实就是子数组的长度
func totalFruit(fruits []int) int {
	result := 0                    // 总结果
	fruitType := make(map[int]int) // 使用一个map记录当前水果的类型及收集到的个数

	// 不断向前移动右指针进行水果收集
	for l, r := 0, 0; r < len(fruits); r++ {
		// 记录新收集的水果种类并递增其个数
		fruitType[fruits[r]]++

		// 当当前收集的水果种类大于果篮数量时，不断向前移动左指针将水果移出果篮，直到水果种类个数等于果篮个数
		for ; len(fruitType) > 2; l++ {
			// 递减左指针指向水果种类的个数
			fruitType[fruits[l]]--
			// 若该水果被收集的个数为0了，则删掉当前收集的该水果种类，表示当前没有收集到当前种类的水果
			if fruitType[fruits[l]] == 0 {
				delete(fruitType, fruits[l])
			}
		}

		// 更新总结果，因为一棵树只能采摘一个水果，所以最终收集的水果数量其实就是子数组的长度
		result = max(result, r-l+1)
	}

	return result
}
