package main

// 153. 寻找旋转排序数组中的最小值

// 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
// 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
// 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
// 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
//
// 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

// findMin .
// 同 leetcode 852. 山脉数组的峰顶索引
// 二分查找
func findMin(nums []int) int {
	l, r := 0, len(nums)-1

	for l < r {
		mid := l + (r-l)/2
		// 当nums[mid]比nums[r]小时，说明mid到r是单调递增的，最小值一定在mid左侧（因为可能正好是mid，所以这里不能用 l <= r 的那种循环，也就不能使用 r=mid-1 这样赋值）
		// 否则说明0到mid是单调递增的，最小值一定出现在mid右侧（因为0到mid是单调递增的且求的是最小值，此时mid一定不会是最小值，所以可以直接 l=mid+1 赋值）
		if nums[mid] < nums[r] {
			r = mid
		} else {
			l = mid + 1
		}
	}

	// 二分查找结束后，l指向的就正好是最小值了
	return nums[l]
}
