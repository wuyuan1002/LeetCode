package main

// 665. 非递减数列

// 给你一个长度为 n 的整数数组 nums ，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
//
// 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

// checkPossibility .
// 最多改变一个数字使得整个数组变成递增（后一个元素大于或等于前一个元素）
// 顺序遍历数组，若找到一个元素比其下一个元素大，说明这两个数字构成一个递减序列，需要对其进行修改
// 对于每个位置nums[i]，除了确保nums[i] <= nums[i+1]外，还要确保nums[i−1] <= nums[i+1]
func checkPossibility(nums []int) bool {
	count := 0
	for i := 0; i < len(nums)-1; i++ {
		// 若当前元素比下一个元素大，说明找到了一个递减的顺序，需要对当前数字或者下一个数字进行更改
		if nums[i] > nums[i+1] {
			// 若变更数字的次数大于1了，说明无法在只改变一个数字的情况下将整个数组变为非递减序列
			if count++; count > 1 {
				return false
			}

			// 1. nums[i] = nums[i+1]
			//
			// 正常情况下当发现nums[i] > nums[i+1]时，将nums[i]赋值为nums[i+1]即可保证nums[i]和nums[i+1]为非递减
			// 如[1, 4, 2, 5]当i为1时发现4、2非递减，此时需要将当前数字赋值为下一个数字的值，使得数组变为[1, 2, 2, 5]为非递减
			//
			//
			// 2. nums[i+1] = nums[i]
			//
			// 但是若nums[i−1] > nums[i+1]时，便不能将当前数字赋值为下一个数字的值了，
			// 如[3, 4, 2, 5]当i为1时发现4、2非递减，此时若将当前数字赋值为下一个数字的值，数组将变成[3, 2, 2, 5]，
			// 由于nums[i−1] > nums[i+1]，使得整个数组在改变当前数字nums[i]后并不能达到非递减的状态
			//
			// 因此对于每个位置nums[i]，除了确保nums[i] <= nums[i+1]外，还要确保nums[i−1] <= nums[i+1]，
			// 若发现当前数字的后一个数字nums[i+1]比前一个数字nums[i-1]小的时候，应该是将当前数字的后一个数字赋值为当前数字的值，
			// 而不是将当前数字赋值为后一个数字的值，
			// 如[3, 4, 2, 5]当i为1时发现4、2非递减，此时将当前数字的后一个数字赋值为当前数字的值，数组将变成[3, 4, 4, 5]为非递减状态
			if i > 0 && nums[i+1] < nums[i-1] {
				nums[i+1] = nums[i]
			} else {
				nums[i] = nums[i+1]
			}
		}
	}

	return true
}
