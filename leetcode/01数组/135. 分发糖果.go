package main

// 135. 分发糖果

// n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。
//
// 你需要按照以下要求，给这些孩子分发糖果：
//
// 每个孩子至少分配到 1 个糖果。
// 相邻两个孩子评分更高的孩子会获得更多的糖果。
// 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

// candy .
// 先从左到右遍历数组为每个孩子分配糖果（使每个孩子的分配满足左规则）
// 再从右到左遍历数组，继续为每个孩子分配糖果（使每个孩子的分配满足右规则）
// 每个孩子最终分到的糖果既要满足左规则也要满足右规则，也就是取两次遍历分到糖果的最大值
//
// eg:
// 如对于[5, 7, 8, 3, 4, 2, 1]进行两次遍历，计算每个孩子最终给分配的糖果数量:
//
// l: 从左到右遍历数组，满足左规则的糖果分配数量、r: 从右到左遍历数组，满足右规则的糖果分配数量
//
// 4 |
// 3 |              l         r
// 2 |         l    r         l    r
// 1 |    lr   r         lr        l    lr
// 0 |
//   +--------------------------------------
//        5    7    8    3    4    2    1
//
// 计算每个孩子既满足左规则又满足右规则的糖果分配数量:
// 5: max(1, 1): 1
// 7: max(2, 1): 2
// 8: max(3, 2): 3
// 3: max(1, 1): 1
// 4: max(2, 3): 3
// 2: max(1, 2): 2
// 1: max(1, 1): 1
func candy(ratings []int) int {
	// 记录每个人分到的糖果数量
	perCount := make([]int, len(ratings))

	// 从左到右遍历数组，计算为每个孩子分配满足左规则的糖果个数
	for i := 0; i < len(ratings); i++ {
		// 每个人至少分到一个糖果，先默认给每个人分一个糖果
		perCount[i] = 1
		// 如果当前孩子比他左面的孩子评分高，则当前孩子分到的糖果应该比其左面孩子多
		if i > 0 && ratings[i] > ratings[i-1] {
			perCount[i] = perCount[i-1] + 1
		}
	}

	// 从右到左遍历数组，计算为每个孩子分配满足右规则的糖果个数，同时累加发放糖果的总个数
	sum := 0
	for j := len(ratings) - 1; j >= 0; j-- {
		// 如果当前孩子比他右面的孩子评分高，那么要在满足左规则的前提下，满足当前孩子分到的糖果应该比其右面孩子多，因此此处要取最大值
		if j < len(ratings)-1 && ratings[j] > ratings[j+1] {
			perCount[j] = max(perCount[j], perCount[j+1]+1)
		}

		// 累加当前孩子分到的糖果个数
		sum += perCount[j]
	}

	// 返回总共需要分发的糖果数量
	return sum
}
