package main

// 523. 连续的子数组和

// 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：
//
// 子数组大小 至少为 2 ，且
// 子数组元素总和为 k 的倍数。
// 如果存在，返回 true ；否则，返回 false 。
//
// 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。

// checkSubarraySum .
// leetcode 560. 和为 K 的子数组
//
// 前缀和 -- 从数组第0项到当前项的和 -- 相当于求数组中和为K的倍数的子数组
// 假设sum[i]表示nums[0, i]区间的数字之和，那么对于区间nums[l, r]若要满足题目要求（即该区间子数组的合为k的整数倍）
// 此时要满足：sum[r] − sum[l−1] = n * k
//
// ↓ ↓ ↓ 转化为 ↓ ↓ ↓
//
// sum[r] / k − sum[l−1] / k = n
// 要使得两者除k相减为整数，需要满足 sum[r] 和 sum[l−1] 对k取余相同
// 也就是说，我们只需要枚举右端点r，然后在枚举右端点r的时候检查是否出现过左端点l，使得sum[r]和sum[l−1]对k取余相同即可
//
// 如何快速查找是否存在左端点l的前缀和对k取余得数是否等于右端点前缀和对k取余得数呢 -> 使用一个map（prefixSum）存前缀和与k取余后的得数为n的第一个的idx
func checkSubarraySum(nums []int, k int) bool {
	// prefixSum[n] = idx: 表示区间nums[0, idx]子数组的前缀和与k取余后的得数为n（前缀和与k取余后的得数为n的第一个的idx），初始设置一个取余后得数为0的下标为-1 -- 用来快速查找一个取余后的数字是否存在以及其下标是多少
	prefixSum := map[int]int{0: -1}

	// 不断遍历数组中的每一项，计算其前缀和sum，并查看map中是否存在下标idx，满足其前缀和与k取余后的得数与当前下标前缀和与k取余后的得数相同
	sum := 0 // sum: nums从第0项到当前项的和
	for i := 0; i < len(nums); i++ {
		// 更新当前以当前数字结尾的前缀和
		sum += nums[i]

		// 判断map中是否存在下标idx，满足其前缀和与k取余后的得数与当前下标前缀和与k取余后的得数相同，
		// 若出现过且子数组长度大于2则说明存在满足条件的子数组直接返回结果，若没有出现过则将这个取余得数和下标映射关系存入map
		if idx, ok := prefixSum[sum%k]; ok {
			if i-idx >= 2 {
				return true
			}
		} else {
			// 标记当前前缀和与k取余后的得数出现的下标 -- 若当前前缀和与k取余后的得数已经出现过，则不会进行更新（只记录第一次出现时的下标）
			prefixSum[sum%k] = i
		}
	}

	return false
}
