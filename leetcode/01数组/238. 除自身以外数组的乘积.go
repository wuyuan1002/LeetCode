package main

// 238. 除自身以外数组的乘积

// 给你一个整数数组 nums，返回 数组 answer ，
// 其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

// productExceptSelf .
// 数组中每个数字的 前缀数字之积 * 后缀数字之积 就是这个数字除自身以外数字的乘积
// 两次遍历数组，正序遍历计算每个数字的前缀之积，倒序遍历计算每个数字的后缀之积，然后将每个数字的前缀之积和后缀之积相乘即得到答案
// 在计算后缀之积时，可以不使用额外的数组进行记录，而是使用一个变量来存储每个数字的后缀之积，节省时间和空间复杂度
func productExceptSelf(nums []int) []int {
	// 构建结果数组，第一次正序遍历时，暂时存储每个数字的前缀之积，然后倒序遍历时将每个数字的后缀之积乘到每个数字对应的位置即得到答案
	result := make([]int, len(nums))

	// 1. 正序遍历数组计算每个数字的前缀之积 -- result[i]表示索引i左侧所有元素的乘积（即每个数字的前缀之积）
	// 第一个元素左侧没有元素，所以 result[0] = 1
	result[0] = 1
	for i := 1; i < len(nums); i++ {
		// 索引为i的数字的前缀之积 = 索引为i-1的前缀之积 * 索引为i-1的数字
		result[i] = result[i-1] * nums[i-1]
	}

	// 2. 倒序遍历数组计算每个数字的后缀之积，然后将后缀之积乘到对应的result上得到结果
	// 使用变量R存储每个数字的后缀之积，表示每个数字右侧的所有数字的乘积，最后一个数字右侧没有元素，所以accu初始值为1
	R := 1
	for i := len(nums) - 1; i >= 0; i-- {
		// 对于当前数字索引为i，左边的乘积为result[i]，右边的乘积为R -- 将当前数字nums[i]的前缀之积和后缀之积相乘即得到当前数字的答案
		result[i] *= R
		// 更新后缀之积 -- 将当前数字乘到R上，得到前一个数字的后缀之积
		R *= nums[i]
	}

	return result
}
