package main

// 424. 替换后的最长重复字符

// 给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。
//
// 在执行上述操作后，返回 包含相同字母的最长子字符串的长度。

// characterReplacement .
// leetcode 1004. 最大连续1的个数 III
//
// 滑动窗口
// 不断遍历字符串中的每一个位置作为右端点，求满足滑动窗口内除了出现次数最多的那个字符外，剩余的字符数量不超过k个的最大窗口长度
//
// maxCnt并不是当前窗口内出现次数最多字母的次数，而是历史窗口中出现次数最多字母的次数，
// 因为找到一个满足条件的窗口之后，接下来需要去找一个更大的窗口, 之前找到的那个窗口的大小 = r-l+1 = maxCnt+k，
// 所以在k固定不变的前提下，要找更大的那个窗口，也就等价于找能够使得maxCnt增大的新的窗口，
// 也就是说在改变左窗口端点之后，判断接下来新加入的字母的个数是否能超过maxCnt（因为只有新加入来的字母才有可能使得最终的maxCnt增大）
func characterReplacement(s string, k int) int {
	result := 0

	// 用来记录当前窗口中各字符出现的次数
	count := make([]int, 26)
	// 窗口左端点、历史窗口中重复出现次数最多的字母的出现次数
	l, maxCnt := 0, 0

	// 不断向右移动窗口右端点，统计窗口中出现的字符个数，并更新符合条件的窗口最大值
	for r, c := range s {
		// 递增当前字符出现的次数
		count[c-'A']++

		// 更新窗口出现最多的字符出现的次数
		maxCnt = max(maxCnt, count[c-'A'])

		// 若窗口中除出现最多的字符外，其余字符出现的次数大于k次了，此时说明k不够用了，将左指针向前移动一位并递减左指针字符出现次数
		if r-l+1 > maxCnt+k {
			count[s[l]-'A']--
			l++
		}

		// 更新符合条件的最大窗口长度 -- 即除出现次数最多的字符外其余字符出现次数小于等于k
		result = max(result, r-l+1)
	}

	// 最终的窗口长度就是满足条件的最大窗口长度 -- 这里的返回值就是最终的窗口长度：len(s)-l == r-l+1
	return result
}
